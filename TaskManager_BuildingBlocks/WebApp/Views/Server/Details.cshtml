@{
    ViewData["Title"] = "Details";
}
<div class="container-fluid">
    <div class="row">
        <div class="col-md-3">
            <h1>Details</h1>

            <div>
                <h4>@ViewData["currentServer"].GetType().GetProperty("ServerName").GetValue(ViewData["currentServer"])</h4>
                <hr />
                <select id="metricNameList" onChange="selectedMetricChange()">
                    @foreach (var metric in ViewData["currentServerMetricsNames"] as List<BusinessLayer.Metric>)
                    {
                        <option value="@metric.Name">@metric.Name</option>
                    }
                </select>
                <hr />
                <input type="number" value="5" id="metricAmount" min="1" max="20" />
                <input type="button" id="refreshBtn" onclick="selectedMetricChange()" class="btn btn-success" value="Refresh" />
            </div>
            <hr />
            <div>
                <a asp-action="AddRule" asp-route-id=@ViewData["currentServer"]>Create Rule</a>
            </div>
            <div>
                <a asp-action="Index">Back to List</a>
            </div>
        </div>
        <div id="graphContainer" class="col-md-9">
            <canvas id="metricChart"></canvas>
        </div>
    </div>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
<script>
    var select = document.getElementById("metricNameList");
    var amount = 5;
    var xlabels = [];
    var chart;

    selectedMetricChange();

    function selectedMetricChange() {
        var xyValues = [];
        amount = document.querySelector("#metricAmount").value
        var metricPoints = "";

        var html = fetch(window.location.origin + "/Server/Get/@ViewData["currentServer"].GetType().GetProperty("ServerId").GetValue(ViewData["currentServer"])?name=" +
            select.options[select.selectedIndex].value + "&amount=" + amount, { mode: "no-cors" }).then(resp => resp.text()).then(data => GenerateChart(data))
    }

    var resetCanvas = function () {
        $('#metricChart').remove(); // this is my <canvas> element
        $('#graphContainer').append('<canvas id="metricChart"><canvas>');
    };

    function GenerateChart(fetchedJsonData) {
        resetCanvas();
        let canvas = document.getElementById('metricChart');
        const context = canvas.getContext("2d");
        console.log(context)
        context.clearRect(0,0,canvas.width,canvas.height)
        let jsonData = JSON.parse(fetchedJsonData.replaceAll("\\", ""))
        let metricPoints = [];
        let maxPoints = [];
        let minPoints = [];
        let xlabels = [];
        for (let i = 0; i < amount; i++) {
            if (jsonData[i.toString()] != null) {
                metricPoints.push(jsonData[i.toString()]["Value"])
                maxPoints.push(jsonData["TypeData"]["Max"])
                minPoints.push(jsonData["TypeData"]["Min"])
                xlabels.push(jsonData[i.toString()]["Date"])
            }
        }

        var ylabels = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

        chart = new Chart("metricChart", {
            type: "line",
            data: {
                labels: xlabels.reverse(),
                datasets: [{
                    label: select.options[select.selectedIndex].value,
                    pointRadius: 4,
                    data: metricPoints.reverse(),
                    borderColor: 'darkblue',
                    pointBackgroundColor: function (context) {
                        var index = context.dataIndex;
                        var value = context.dataset.data[index];
                        return value < jsonData["TypeData"]["Min"] ? 'red' :  // draw negative values in red
                            value > jsonData["TypeData"]["Max"] ? 'red' :    // else, alternate values in blue and green
                                'lightgreen';
                    },
                }, {
                    type: "line",
                    data: maxPoints,
                    label: "Max",
                    borderColor: "red",
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    borderWidth: 1,
                    backgroundColor: 'rgba(0,0,0,0)',
                    hitRadius: 0
                    }, {
                    type: "line",
                    data: minPoints,
                    label: "Min",
                    borderColor: "red",
                    borderWidth: 1,
                    backgroundColor: 'rgba(0,0,0,0)',
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    hitRadius: 0
                    }]
            }, options: {
                scales: {
                    yAxes: [{
                        ticks: {
                            max: 100,
                            min: 0
                        }
                    }]
                },
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: 'rgb(255, 99, 132)'
                        }
                    }
                }
            }
        });
    }
</script>
